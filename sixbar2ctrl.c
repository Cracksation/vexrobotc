#pragma config(Sensor, in1,    programSelect,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  wheelEnc_right, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  wheelEnc_left,  sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  armEnc_right,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  armEnc_left,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, limitSwitch_down, sensorTouch)
#pragma config(Sensor, dgtl12, limitSwitch_up, sensorTouch)
#pragma config(Motor,  port1,           conveyorMot,   tmotorVex393, openLoop)
#pragma config(Motor,  port2,           backMot_right, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           backMot_left,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           frontMot_right, tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontMot_left, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           armMot_right1, tmotorVex393, PIDControl, encoder, encoderPort, dgtl5, 1000)
#pragma config(Motor,  port7,           armMot_right2, tmotorVex393, PIDControl, encoder, encoderPort, dgtl5, 1000)
#pragma config(Motor,  port8,           armMot_left1,  tmotorVex393, PIDControl, encoder, encoderPort, dgtl7, 1000)
#pragma config(Motor,  port9,           armMot_left2,  tmotorVex393, PIDControl, encoder, encoderPort, dgtl7, 1000)
#pragma config(Motor,  port10,          intakeMot,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                - Berthoud Robotics Team 1069A -                                    *|
|*                                        VEX Toss UP 2013                                            *|
|*                                                                                                    *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)                                                                                              *|
|*    2)                                                                                              *|
|*    3)                                                                                              *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]              [Name]              [Type]              [Description]                   *|
|*    see pragma statements above for motor and sensor configurations                                 *|
|*                                                                                                    *|
\*----------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------
/ Channel variable names:
/
/ Ch1 - X-Axis - Right Joystick
/ Ch2 - Y-Axis - Right Joystick
/ Ch3 - Y-Axis - Left Joystick
/ Ch4 - X-Axis - Left Joystick
/
/ Button variable names:
/
/ Btn5U - Button group 5 - "U" (up)
/ Btn5D - Button group 5 - "D" (down)
/ Btn6U - Button group 6 - "U" (up)
/ Btn6D - Button group 6 - "D" (down)
/ Btn7U - Button group 7 - "U" (up)
/ Btn7D - Button group 7 - "D" (down)
/ Btn7L - Button group 7 - "L" (left)
/ Btn7R - Button group 7 - "R" (right)
/ Btn8U - Button group 8 - "U" (up)
/ Btn8D - Button group 8 - "D" (down)
/ Btn8L - Button group 8 - "L" (left)
/ Btn8R - Button group 8 - "R" (right)
/
/ Channel variable names for VEXnet Transmitter 2:
/
/ Ch1Xmtr2 - X-Axis - Right Joystick
/ Ch2Xmtr2 - Y-Axis - Right Joystick
/ Ch3Xmtr2 - Y-Axis - Left Joystick
/ Ch4Xmtr2 - X-Axis - Left Joystick
/
/ Button variable names for VEXnet Transmitter 2:
/
/ Btn5UXmtr2 - Button group 5 - "U" (up)
/ Btn5DXmtr2  - Button group 5 - "D" (down)
/ Btn6UXmtr2 - Button group 6 - "U" (up)
/ Btn6DXmtr2 - Button group 6 - "D" (down)
/ Btn7UXmtr2 - Button group 7 - "U" (up)
/ Btn7DXmtr2 - Button group 7 - "D" (down)
/ Btn7LXmtr2 - Button group 7 - "L" (left)
/ Btn7RXmtr2 - Button group 7 - "R" (right)
/ Btn8UXmtr2 - Button group 8 - "U" (up)
/ Btn8DXmtr2 - Button group 8 - "D" (down)
/ Btn8LXmtr2 - Button group 8 - "L" (left)
/ Btn8RXmtr2 - Button group 8 - "R" (right)
/----------------------------------------------------------------------------------------------------*/


//----------------------------------------------------------------------------------------------------*/
#define abs(X) ((X < 0) ? -1 * X : X)

//----------------------------------------------------------------------------------------------------*/
static const word armMaxPositionValue           = 100;
static const word armBuckyDumpPositionValue     = 75;
static const word armBigBallPositionValue       = 47;
static const word armBumpPositionValue          = 10;
static const word armBuckyPickupPositionValue   = 0;
static const word armMinPositionValue           = 0;

//----------------------------------------------------------------------------------------------------*/
bool armMotorsMovingUp( void )
{
    return (
            (motor[armMot_right1] > 0) ||
            (motor[armMot_right2] > 0) ||
            (motor[armMot_left1]  > 0) ||
            (motor[armMot_left2]  > 0)
    );
}

//----------------------------------------------------------------------------------------------------*/
bool armMotorsMovingDown( void )
{
    return (
            (motor[armMot_right1] < 0) ||
            (motor[armMot_right2] < 0) ||
            (motor[armMot_left1]  < 0) ||
            (motor[armMot_left2]  < 0)
    );
}

//----------------------------------------------------------------------------------------------------*/
word getArmNextUpPosition( void )
{
    // Using right arm encoder to determine actual position
    word armPosition = SensorValue[armEnc_right];

    //if( armPosition < (armMinPositionValue + ( armBuckyPickupPositionValue - armMinPositionValue)/2) )
    //{
    //    return armBuckyPickupPositionValue;
    //}

    if( armPosition < (armBuckyPickupPositionValue + ( armBumpPositionValue - armBuckyPickupPositionValue)/2) )
    {
        return armBumpPositionValue;
    }

    if( armPosition < (armBumpPositionValue + (armBigBallPositionValue - armBumpPositionValue)/2) )
    {
        return armBigBallPositionValue;
    }

    if( armPosition < (armBigBallPositionValue + (armBuckyDumpPositionValue - armBigBallPositionValue)/2) )
    {
        return armBuckyDumpPositionValue;
    }

    return armMaxPositionValue;
}

//----------------------------------------------------------------------------------------------------*/
word getArmNextDownPosition( void )
{
    // Using right arm encoder to determine actual position
    word armPosition = SensorValue[armEnc_right];

    if( armPosition > (armBuckyDumpPositionValue + ( armMaxPositionValue - armBuckyDumpPositionValue)/2) )
    {
        return armBuckyDumpPositionValue;
    }

    if( armPosition > (armBigBallPositionValue + (armBuckyDumpPositionValue - armBigBallPositionValue)/2) )
    {
        return armBigBallPositionValue;
    }

    if( armPosition > (armBumpPositionValue + (armBigBallPositionValue - armBumpPositionValue)/2) )
    {
        return armBumpPositionValue;
    }

    if( armPosition > (armBuckyPickupPositionValue + (armBumpPositionValue - armBuckyPickupPositionValue)/2) )
    {
        return armBuckyPickupPositionValue;
    }

    return armMinPositionValue;
}

//----------------------------------------------------------------------------------------------------*/
word getArmCommandValue( word setpoint, word armPosition, word armPosOld )
{
    word errorArmPos		  = setpoint - armPosition;
    word armGainP         = 1;
    word armCommandOffset = 0;
    word commandValue			= 0;
		word armSpeed					= abs( (armPosition - armPosOld) );

    // set gain to higher value for UP motion
    if( errorArmPos >= 0 )
    {
        // going up
    		if( errorArmPos > 30 )
    		{
    			armGainP = 3;
    		}
    		else if( errorArmPos > 10 )
    		{
    			armGainP = 5;
    		}
    		else
    		{
    			armGainP = 7;
    		}
		}
    else
    {
        // going down
    		if( errorArmPos < -10 )
    		{
    			armGainP = 2;
    		}
    		else if( errorArmPos < -5 )
    		{
    			armGainP = 3;
    		}
    		else
    		{
    			armGainP = 10;
    		}

   		if( armPosition > 45 )
    	{
    		armGainP = 1;
    		armCommandOffset = 0;
    	}
    	else if( armPosition > 20 )
    	{
    		armCommandOffset = 10;
    	}
    	else
    	{
    		armCommandOffset = 5;
    	}

    	if( armSpeed > 2 )
    	{
    		armCommandOffset = 200;
    	}
    	else if( armSpeed > 1 )
    	{
    		armCommandOffset = 300;
    	}
    }

    commandValue = armGainP * errorArmPos + armCommandOffset;
    commandValue = (commandValue >  127) ?  127 : commandValue;
    commandValue = (commandValue < -127) ? -127 : commandValue;

 	return( commandValue );

}

//----------------------------------------------------------------------------------------------------*/
void controlArmToPosition( word setpoint )
{
    word commandValueRight = 0;
    word commandValueLeft  = 0;

    word armposOld;

    armposOld = SensorValue[armEnc_right];
    wait10Msec(1);
    commandValueRight = getArmCommandValue( setpoint, SensorValue[armEnc_right], armposOld );

    armposOld = SensorValue[armEnc_left];
    wait10Msec(1);
    commandValueLeft  = getArmCommandValue( setpoint, SensorValue[armEnc_left], armposOld );

    motor[armMot_right1] = commandValueRight;
    motor[armMot_right2] = commandValueRight;

    motor[armMot_left1] = commandValueLeft;
    motor[armMot_left2] = commandValueLeft;
}

//----------------------------------------------------------------------------------------------------*/
void setArmMotorToZero( void )
{
    motor[armMot_right1] = 0;
    motor[armMot_right2] = 0;
    motor[armMot_left1]  = 0;
    motor[armMot_left2]  = 0;
}

//----------------------------------------------------------------------------------------------------*/
// Input the distance in TENTHS of inches
// 10 inches is input at 100
// 34.5 inches is input as 345
// Use negative distances to backup.
// To backup 10 inches input distance as -100
// To backup 34.5 inches input distance as -345
// Wheel is ~ 5 inches in diameter
// Circumference is PI * Diameter or ~ 15.7 inches
// 360 encoder counts per revolution of wheel
// 360 counts / rev  /  15.7 inches / rev => 22.9 counts / inch
word getCountsFromDistance( word distance )
{
	return (23 * distance) / 10;
}


//----------------------------------------------------------------------------------------------------*/
// Input the distance in TENTHS of inches
// 10 inches is input at 100
// 34.5 inches is input as 345
// Use negative distances to backup.
// To backup 10 inches input distance as -100
// To backup 34.5 inches input distance as -345
//
// masterPower is a value between 0 and 127 for motor power / speed.
//
word moveStraightForDistance( word distance, word masterPower )
{
    //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
    word totalCounts = 0;

    word CountsPerInch = 30;
    word countGoal = (CountsPerInch * distance) / 10;

    //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
    //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
    //veering off course at the start of the function.
    word slavePower = masterPower - 5;

    word error = 0;

    word kp = 5;

    SensorValue[wheelEnc_right] = 0;
    SensorValue[wheelEnc_left]  = 0;

    //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
    while(abs(totalCounts) < countGoal)
    {
      //Proportional algorithm to keep the robot going straight.
        // Left side is the slave side.
        // Subtract left from right.
        // If left is behind right error will be positive and will add value to left side wheels
        // If left is ahead of right error will be negative and will subtract value from left side wheels
        error = SensorValue[wheelEnc_right] - SensorValue[wheelEnc_left];
        slavePower += error / kp;

        // clear the encoders before applying new power values
        SensorValue[wheelEnc_right] = 0;
      SensorValue[wheelEnc_left] = 0;

      // back wheels are 5 inch, front are 4 inch, drive the back wheels proportionally slower
        motor[backMot_right]  = masterPower * 0.8;
        motor[frontMot_right] = masterPower;
        motor[backMot_left]   = slavePower * 0.8;
        motor[frontMot_left]  = slavePower;

        // wait while the robot moves for a tenth of a second
        wait1Msec(100);

      //Add this iteration's encoder values to totalTicks.
      totalCounts+= SensorValue[wheelEnc_right];
    }

    // Stop the loop once the encoders have counted up the correct number of encoder ticks.
    motor[backMot_right]  = 0;
    motor[frontMot_right] = 0;
    motor[backMot_left]   = 0;
    motor[frontMot_left]  = 0;

    return totalCounts;
}


//----------------------------------------------------------------------------------------------------*/

//----------------------------------------------------------------------------------------------------*/

//----------------------------------------------------------------------------------------------------*/

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main ()
{
    // define easy to remember variables for the vexRT commands
    word speedCommandLeft;// desired speed command for left wheels, from left joystick
    word speedCommandRight;// desired speed command for right wheels, from right joystick
    word speedCommandThreshold = 10;// helps to eliminate 'noise' from a joystick that isn't perfectly at (0,0)

    bool armUpCommand = false;// true if the arm is being commanded to go up
    bool armDownCommand = false;// true if the arm is being commanded to go down
    bool armUpLimitReached = false;
    bool armDownLimitReached = false;
    bool moveRobotForward = false;
    bool moveRobotBackward = false;
    bool spinRobotLeft = false;
    bool spinRobotRight = false;
    bool conveyorUpCommand = false;// true if the conveyorMot is being commanded to pull balls away from intakeMot
    bool conveyorDownCommand = false;// true if the conveyorMot is being commanded to push balls toward intakeMot
    bool intakeInCommand = false;
    bool intakeOutCommand = false;

    // arm setpoint commands
    bool armBumpCmdBtn = false;
    bool armBigBallCmdBtn = false;
    bool armBuckyPickupCmdBtn = false;
    bool armBuckyDumpCmdBtn = false;

    bool armUpOnePositionCmdBtn = false;
    bool armUpOnePositionCmdBtnReleased = true;

    bool armDownOnePositionCmdBtn = false;
    bool armDownOnePositionCmdBtnReleased = true;

    word intakeSpeed = 127;
    word conveyorSpeed = 127;

    word armCtrlPositionValue = 0;

    // clear and stop all motors by resetting power to zero
    motor[ port1 ] = 0;
    motor[ port2 ] = 0;
    motor[ port3 ] = 0;
    motor[ port4 ] = 0;
    motor[ port5 ] = 0;
    motor[ port6 ] = 0;
    motor[ port7 ] = 0;
    motor[ port8 ] = 0;
    motor[ port9 ] = 0;
    motor[ port10 ] = 0;

    SensorValue[ wheelEnc_left ] = 0;
    SensorValue[ wheelEnc_right ] = 0;
    SensorValue[ armEnc_left ] = 0;
    SensorValue[ armEnc_right ] = 0;

    while(1 == 1)
    {
        // read all of the vex controller inputs to figure out what
        // the driver wants to do.
        speedCommandLeft                = vexRT[Ch3] + vexRT[Ch3Xmtr2];//
        speedCommandRight               = vexRT[Ch2] + vexRT[Ch2Xmtr2];//

        intakeInCommand                 = (vexRT[Btn6U] == 1) || (vexRT[Btn6UXmtr2]);
        intakeOutCommand                = (vexRT[Btn6D] == 1) || (vexRT[Btn6DXmtr2]);

        conveyorUpCommand               = (vexRT[Btn5U] == 1) || (vexRT[Btn5UXmtr2]);
        conveyorDownCommand             = (vexRT[Btn5D] == 1) || (vexRT[Btn5DXmtr2]);

        armBumpCmdBtn                   = (vexRT[Btn7U] == 1) || (vexRT[Btn7UXmtr2]);
        armBigBallCmdBtn                = (vexRT[Btn7L] == 1) || (vexRT[Btn7LXmtr2]);
        armBuckyPickupCmdBtn            = (vexRT[Btn7D] == 1) || (vexRT[Btn7DXmtr2]);
        armBuckyDumpCmdBtn              = (vexRT[Btn7R] == 1) || (vexRT[Btn7RXmtr2]);

        armUpOnePositionCmdBtn          = (vexRT[Btn8U] == 1) || (vexRT[Btn8UXmtr2]);
        armDownOnePositionCmdBtn        = (vexRT[Btn8D] == 1) || (vexRT[Btn8DXmtr2]);

        armUpCommand                    = (vexRT[Btn8R] == 1) || (vexRT[Btn8RXmtr2]);
        armDownCommand                  = (vexRT[Btn8L] == 1) || (vexRT[Btn8LXmtr2]);

        armUpLimitReached               = SensorValue( limitSwitch_up ) == 1;
        armDownLimitReached             = SensorValue( limitSwitch_down ) == 1;

        //------------------------ WHEEL COMMANDS -----------------------------------------
        // check the wheel speed commands from the controller and move the wheels if the
        // controller input value is greater than the joystick noise threshold
        if(abs(speedCommandLeft) < speedCommandThreshold)
        {
            motor[frontMot_left] = 0;
            motor[backMot_left] = 0;
        }
        else
        {
            motor[frontMot_left] = (speedCommandLeft);
            motor[backMot_left] = (speedCommandLeft*0.8);
        }

        if(abs(speedCommandRight) < speedCommandThreshold)
        {
            motor[frontMot_right] = 0;
            motor[backMot_right] = 0;
        }
        else
        {
            motor[frontMot_right] = (speedCommandRight);
            motor[backMot_right] = (speedCommandRight*0.8);
        }

        //------------------------ ARM COMMANDS -----------------------------------------
        // if no command buttons are being pushed then shut both motors off
        // if both command buttons are being pushed at the same time then shut both motors off
        // else move the motor in the direction of the button being pushed
        // check the limit switches and shut off the arm motors if the limit is reached

        // clear OTHER fixed position buttons when a new button is pressed
        // if the arm UP or arm DOWN buttons are pressed then override the command buttons and clear the
        // pressed / released state
        // check up and down limit switches.  If either limit switch is
        // pressed and the motor is trying to go in that direction then shut
        // the motor off

        // check for buttons released
        if( !armUpOnePositionCmdBtn )
        {
            armUpOnePositionCmdBtnReleased = true;
        }

        if( !armDownOnePositionCmdBtn )
        {
            armDownOnePositionCmdBtnReleased = true;
        }

        if(armDownLimitReached && (armDownCommand || armMotorsMovingDown()))
        {
            armCtrlPositionValue = armMinPositionValue;
        }
        else if(armUpLimitReached && (armUpCommand || armMotorsMovingUp()))
        {
            armCtrlPositionValue = armMaxPositionValue;
        }
        else if( armUpCommand && (time10[T4] != 0) )
        {
            armCtrlPositionValue++;
            ClearTimer(T4);
        }
        else if( armDownCommand && (time10[T4] != 0) )
        {
            armCtrlPositionValue--;
            ClearTimer(T4);
        }
        else if( armUpOnePositionCmdBtn )
        {
            if( armUpOnePositionCmdBtnReleased )
            {
                armUpOnePositionCmdBtnReleased = false;
                // Move from present arm position to the next higher position
                armCtrlPositionValue = getArmNextUpPosition();
            }
        }
        else if( armDownOnePositionCmdBtn )
        {
            if( armDownOnePositionCmdBtnReleased )
            {
                armDownOnePositionCmdBtnReleased = false;
                // Move from present arm position to the next lower position
                armCtrlPositionValue = getArmNextDownPosition();
            }
        }
        else if( armBumpCmdBtn )
        {
            armCtrlPositionValue = armBumpPositionValue;
        }
        else if( armBigBallCmdBtn )
        {
            armCtrlPositionValue = armBigBallPositionValue;
        }
        else if( armBuckyDumpCmdBtn )
        {
            armCtrlPositionValue = armBuckyPickupPositionValue;
        }
        else if( armBuckyPickupCmdBtn )
        {
            armCtrlPositionValue = armBuckyDumpPositionValue;
        }

        // CAP arm control setpoint to MIN or MAX
				armCtrlPositionValue = (armCtrlPositionValue > armMaxPositionValue) ? armMaxPositionValue : armCtrlPositionValue;
				armCtrlPositionValue = (armCtrlPositionValue < armMinPositionValue) ? armMinPositionValue : armCtrlPositionValue;

        controlArmToPosition( armCtrlPositionValue );

        //------------------------ INTAKE COMMANDS -----------------------------------------
        if ( intakeInCommand )
        {
            motor[ intakeMot ] = intakeSpeed;
        }
        else if (intakeOutCommand )
        {
            motor[ intakeMot ] = -intakeSpeed;
        }
        else
        {
            motor[ intakeMot ] = 0;
        }

        //------------------------ CONVEYOR COMMANDS -----------------------------------------
        if ( conveyorUpCommand )
        {
            motor[ conveyorMot ] = conveyorSpeed;
        }
        else if (conveyorDownCommand )
        {
            motor[ conveyorMot ] = -conveyorSpeed;
        }
        else
        {
            motor[ conveyorMot ] = 0;
        }

    } // while(1)
} // main task
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
